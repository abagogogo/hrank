#!/bin/python3
#
# Complete the 'roadsAndLibraries' function below.
#
# The function is expected to return a LONG_INTEGER.
# The function accepts following parameters:
#  1. INTEGER n
#  2. INTEGER c_lib
#  3. INTEGER c_road
#  4. 2D_INTEGER_ARRAY cities
#
from collections import defaultdict
from collections import deque

class Graph:
    def __init__(self):
        self.nodes = []
        self.edges = defaultdict(set)
    def clone(self):
        g = Graph()
        g.ndoes = self.nodes[:]
        for n in self.nodes:
            for e in self.edges[n]:
                g.edges[n].add(e)
        return g

def count_clusters(g):
    nclust = 0;
    visited = set()
    n = len(g.nodes)
    csize = []

    for node in g.nodes:
        if node in visited: continue
        visited.add(node)

        size = 1
        q = deque()
        q.appendleft(node)
        while q:
            cur = q.pop()
            for next in g.edges[cur]:
                if next in visited: continue
                visited.add(next)
                q.appendleft(next)
                size += 1
        nclust += 1
        csize.append(size)
    return nclust,csize
        
def roadsAndLibraries(n, c_lib, c_road, cities):
    # Write your code here
    g = Graph()
    g.nodes = range(1, n+1)
    for a,b in cities:
        g.edges[a].add(b)
        g.edges[b].add(a)
    nc, cs = count_clusters(g)
    
    return min(c_lib * n, c_lib * nc + sum((x - 1) * c_road for x in cs))

// C++ - DFS
using GRAPH=unordered_map<int, vector<int>>;
using NODE_SET=unordered_set<int>;
 
int dfs(GRAPH &graph, int start, NODE_SET &visited) {
    if (graph.find(start) == graph.end()) return 0;
    if (visited.count(start) > 0) return 0;

    visited.insert(start);
    int num_cities = 1;
    for (int next : graph[start]) {
        num_cities += dfs(graph, next, visited);
    }
    return num_cities;
}

long roadsAndLibraries(int n, int c_lib, int c_road, vector<vector<int>> cities) {    
    GRAPH graph;
    NODE_SET visited;

    for (int i = 1; i <= n; ++i) graph[i] = {};    
    for (auto r : cities) {
        graph[r[0]].push_back(r[1]);
        graph[r[1]].push_back(r[0]);
    }

    long cost = 0;    
    for (auto it = graph.begin(); it != graph.end(); ++it) {
        int num_cities = dfs(graph, it->first, visited);
        if (num_cities > 0) {
            if (c_lib < c_road) {
                cost += long(num_cities) * (long)c_lib;
            } else {
                cost += (long)(num_cities - 1) * (long)c_road + (long)c_lib;
            }
        }
    }
    return cost;
}
